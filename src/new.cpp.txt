// #include <rclcpp/rclcpp.hpp>
// #include <geometry_msgs/msg/pose_with_covariance_stamped.hpp>
// #include <geometry_msgs/msg/pose_stamped.hpp>
// #include <geometry_msgs/msg/twist_with_covariance_stamped.hpp>
// #include <nav_msgs/msg/odometry.hpp>
// #include <tf2_ros/transform_broadcaster.h>
// #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>

// #include <deque>

// class PoseTwistFusionNode : public rclcpp::Node {
// public:
//   PoseTwistFusionNode() : Node("pose_twist_fusion_node") {
//     // Existing subscriptions
//     sub_pose_lidar_ = this->create_subscription<geometry_msgs::msg::PoseWithCovarianceStamped>(
//       "/localization/pose_with_covariance", 10,
//       std::bind(&PoseTwistFusionNode::callbackPoseLidar, this, std::placeholders::_1));
//     sub_pose_gnss_ = this->create_subscription<geometry_msgs::msg::PoseWithCovarianceStamped>(
//       "/mgrs_pose", 10,
//       std::bind(&PoseTwistFusionNode::callbackPoseGnss, this, std::placeholders::_1));
//     sub_twist_lidar_ = this->create_subscription<geometry_msgs::msg::TwistWithCovarianceStamped>(
//       "/localization/pose_twist_fusion_filter/twist_with_covariance", 10,
//       std::bind(&PoseTwistFusionNode::callbackTwistLidar, this, std::placeholders::_1));
//     sub_twist_gnss_ = this->create_subscription<geometry_msgs::msg::TwistWithCovarianceStamped>(
//       "/gnss_twist_cov", 10,
//       std::bind(&PoseTwistFusionNode::callbackTwistGnss, this, std::placeholders::_1));

//     // New subscriptions for additional fusions
//     sub_kinematic_state_lidar_ = this->create_subscription<nav_msgs::msg::Odometry>(
//       "/localization/pose_twist_fusion_filter/kinematic_state_lidar", 10,
//       std::bind(&PoseTwistFusionNode::callbackKinematicStateLidar, this, std::placeholders::_1));
//     sub_kinematic_state_gnss_ = this->create_subscription<nav_msgs::msg::Odometry>(
//       "/localization/pose_twist_fusion_filter/kinematic_state_gnss", 10,
//       std::bind(&PoseTwistFusionNode::callbackKinematicStateGnss, this, std::placeholders::_1));

//     sub_biased_pose_lidar_ = this->create_subscription<geometry_msgs::msg::PoseWithCovarianceStamped>(
//       "/localization/pose_twist_fusion_filter/biased_pose_with_covariance_lidar", 10,
//       std::bind(&PoseTwistFusionNode::callbackBiasedPoseLidar, this, std::placeholders::_1));
//     sub_biased_pose_gnss_ = this->create_subscription<geometry_msgs::msg::PoseWithCovarianceStamped>(
//       "/localization/pose_twist_fusion_filter/biased_pose_with_covariance_gnss", 10,
//       std::bind(&PoseTwistFusionNode::callbackBiasedPoseGnss, this, std::placeholders::_1));

//     sub_pose_lidar_simple_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
//       "/localization/pose_twist_fusion_filter/pose_lidar", 10,
//       std::bind(&PoseTwistFusionNode::callbackPoseLidarSimple, this, std::placeholders::_1));
//     sub_pose_gnss_simple_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
//       "/localization/pose_twist_fusion_filter/pose_gnss", 10,
//       std::bind(&PoseTwistFusionNode::callbackPoseGnssSimple, this, std::placeholders::_1));

//     // Existing publishers
//     pub_pose_ = this->create_publisher<geometry_msgs::msg::PoseWithCovarianceStamped>(
//       "/fused/localization/pose_with_covariance", 10);
//     pub_twist_ = this->create_publisher<geometry_msgs::msg::TwistWithCovarianceStamped>(
//       "/fused/localization/pose_twist_fusion_filter/twist_with_covariance", 10);
//     // pub_kinematic_state_ = this->create_publisher<nav_msgs::msg::Odometry>(
//     //   "/fused/localization/pose_twist_fusion_filter/kinematic_state", 10);

//     // New publishers for the additional fused topics
//     pub_fused_kinematic_state_ = this->create_publisher<nav_msgs::msg::Odometry>(
//       "/localization/pose_twist_fusion_filter/kinematic_state", 10);
//     pub_fused_biased_pose_ = this->create_publisher<geometry_msgs::msg::PoseWithCovarianceStamped>(
//       "/localization/pose_twist_fusion_filter/biased_pose_with_covariance", 10);
//     pub_fused_pose_ = this->create_publisher<geometry_msgs::msg::PoseStamped>(
//       "/localization/pose_twist_fusion_filter/pose", 10);

//     tf_br_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);

//     max_buffer_size_ = 15;
//   }

// private:
//   // Buffers for new subscriptions
//   std::deque<nav_msgs::msg::Odometry::SharedPtr> kinematic_state_lidar_buffer_;
//   std::deque<nav_msgs::msg::Odometry::SharedPtr> kinematic_state_gnss_buffer_;
//   std::deque<geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr> biased_pose_lidar_buffer_;
//   std::deque<geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr> biased_pose_gnss_buffer_;
//   std::deque<geometry_msgs::msg::PoseStamped::SharedPtr> pose_lidar_simple_buffer_;
//   std::deque<geometry_msgs::msg::PoseStamped::SharedPtr> pose_gnss_simple_buffer_;

//   size_t max_buffer_size_;

//   // Existing callback methods for fusion
//   // New callback methods
//   void callbackKinematicStateLidar(const nav_msgs::msg::Odometry::SharedPtr msg) {
//     kinematic_state_lidar_buffer_.push_back(msg);
//     if (kinematic_state_lidar_buffer_.size() > max_buffer_size_) {
//       kinematic_state_lidar_buffer_.pop_front();
//     }
//     fuseKinematicState();
//   }

//   void callbackKinematicStateGnss(const nav_msgs::msg::Odometry::SharedPtr msg) {
//     kinematic_state_gnss_buffer_.push_back(msg);
//     if (kinematic_state_gnss_buffer_.size() > max_buffer_size_) {
//       kinematic_state_gnss_buffer_.pop_front();
//     }
//     fuseKinematicState();
//   }

//   void fuseKinematicState() {
//     if (kinematic_state_lidar_buffer_.empty() || kinematic_state_gnss_buffer_.empty()) {
//       return;
//     }

//     auto latest_lidar_odom = kinematic_state_lidar_buffer_.back();
//     auto closest_gnss_odom = findClosestOdometry(kinematic_state_gnss_buffer_, latest_lidar_odom->header.stamp);

//     if (!closest_gnss_odom) {
//       RCLCPP_WARN(this->get_logger(), "No matching GNSS odometry found.");
//       return;
//     }

//     nav_msgs::msg::Odometry fused_odom;
//     fused_odom.header.stamp = this->now();
//     fused_odom.header.frame_id = "map";

//     // lidar weight & gnss weight
//     double weight_lidar = 0.5;
//     double weight_gnss = 0.5;

//     fused_odom.pose.pose.position.x = latest_lidar_odom->pose.pose.position.x * weight_lidar +
//                                       closest_gnss_odom->pose.pose.position.x * weight_gnss;
//     fused_odom.twist.twist.linear.x = latest_lidar_odom->twist.twist.linear.x * weight_lidar +
//                                       closest_gnss_odom->twist.twist.linear.x * weight_gnss;

//     // Publish fused kinematic state
//     pub_fused_kinematic_state_->publish(fused_odom);
//   }

//   void callbackBiasedPoseLidar(const geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr msg) {
//     biased_pose_lidar_buffer_.push_back(msg);
//     if (biased_pose_lidar_buffer_.size() > max_buffer_size_) {
//       biased_pose_lidar_buffer_.pop_front();
//     }
//     fuseBiasedPose();
//   }

//   void callbackBiasedPoseGnss(const geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr msg) {
//     biased_pose_gnss_buffer_.push_back(msg);
//     if (biased_pose_gnss_buffer_.size() > max_buffer_size_) {
//       biased_pose_gnss_buffer_.pop_front();
//     }
//     fuseBiasedPose();
//   }

//   void fuseBiasedPose() {
//     if (biased_pose_lidar_buffer_.empty() || biased_pose_gnss_buffer_.empty()) {
//       return;
//     }

//     auto latest_lidar_pose = biased_pose_lidar_buffer_.back();
//     auto closest_gnss_pose = findClosestPose(biased_pose_gnss_buffer_, latest_lidar_pose->header.stamp);

//     if (!closest_gnss_pose) {
//       RCLCPP_WARN(this->get_logger(), "No matching GNSS biased pose found.");
//       return;
//     }

//     geometry_msgs::msg::PoseWithCovarianceStamped fused_biased_pose;
//     fused_biased_pose.header.stamp = this->now();
//     fused_biased_pose.header.frame_id = "map";

//     // Fusion logic (position/orientation/covariance)
//     double weight_lidar = 0.5;
//     double weight_gnss = 0.5;

//     fused_biased_pose.pose.pose.position.x = latest_lidar_pose->pose.pose.position.x * weight_lidar +
//                                              closest_gnss_pose->pose.pose.position.x * weight_gnss;

//     pub_fused_biased_pose_->publish(fused_biased_pose);
//   }

//   void callbackPoseLidarSimple(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
//     pose_lidar_simple_buffer_.push_back(msg);
//     if (pose_lidar_simple_buffer_.size() > max_buffer_size_) {
//       pose_lidar_simple_buffer_.pop_front();
//     }
//     fuseSimplePose();
//   }

//   void callbackPoseGnssSimple(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
//     pose_gnss_simple_buffer_.push_back(msg);
//     if (pose_gnss_simple_buffer_.size() > max_buffer_size_) {
//       pose_gnss_simple_buffer_.pop_front();
//     }
//     fuseSimplePose();
//   }

//   void fuseSimplePose() {
//     if (pose_lidar_simple_buffer_.empty() || pose_gnss_simple_buffer_.empty()) {
//       return;
//     }

//     auto latest_lidar_pose = pose_lidar_simple_buffer_.back();
//     auto closest_gnss_pose = findClosestPoseSimple(pose_gnss_simple_buffer_, latest_lidar_pose->header.stamp);

//     if (!closest_gnss_pose) {
//       RCLCPP_WARN(this->get_logger(), "No matching GNSS simple pose found.");
//       return;
//     }

//     geometry_msgs::msg::PoseStamped fused_pose;
//     fused_pose.header.stamp = this->now();
//     fused_pose.header.frame_id = "map";

//     // Fusion logic for position/orientation
//     double weight_lidar = 0.5;
//     double weight_gnss = 0.5;

//     fused_pose.pose.position.x = latest_lidar_pose->pose.position.x * weight_lidar +
//                                  closest_gnss_pose->pose.position.x * weight_gnss;

//     pub_fused_pose_->publish(fused_pose);
//   }

//   // Utility functions (findClosestPose, findClosestTwist, findClosestOdometry, etc.) similar to your existing implementations

//   // geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr findClosestPose(
//   //   const std::deque<geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr>& buffer,
//   //   const builtin_interfaces::msg::Time& target_time) {
//   //     geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr closest_msg = nullptr;
//   //     double min_time_diff = std::numeric_limits<double>::max();

//   //     rclcpp::Time target_time_rclcpp(target_time);

//   //     for (const auto& msg : buffer) {
//   //         rclcpp::Time msg_time(msg->header.stamp);
//   //         double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
//   //         if (time_diff < min_time_diff) {
//   //             min_time_diff = time_diff;
//   //             closest_msg = msg;
//   //         }
//   //     }
//   //     return closest_msg;
//   // }

//   // geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr findClosestTwist(
//   //   const std::deque<geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr>& buffer,
//   //   const builtin_interfaces::msg::Time& target_time) {
//   //     geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr closest_msg = nullptr;
//   //     double min_time_diff = std::numeric_limits<double>::max();

//   //     rclcpp::Time target_time_rclcpp(target_time);

//   //     for (const auto& msg : buffer) {
//   //         rclcpp::Time msg_time(msg->header.stamp);
//   //         double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
//   //         if (time_diff < min_time_diff) {
//   //             min_time_diff = time_diff;
//   //             closest_msg = msg;
//   //         }
//   //     }
//   //     return closest_msg;
//   // }

// // geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr findClosestPose(
// //     const std::deque<geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //   geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr closest_msg = nullptr;
// //   double min_time_diff = std::numeric_limits<double>::max();

// //   rclcpp::Time target_time_rclcpp(target_time);

// //   for (const auto& msg : buffer) {
// //     rclcpp::Time msg_time(msg->header.stamp);
// //     double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //     if (time_diff < min_time_diff) {
// //       min_time_diff = time_diff;
// //       closest_msg = msg;
// //     }
// //   }
// //   return closest_msg;
// // }

// // geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr findClosestTwist(
// //     const std::deque<geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //   geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr closest_msg = nullptr;
// //   double min_time_diff = std::numeric_limits<double>::max();

// //   rclcpp::Time target_time_rclcpp(target_time);

// //   for (const auto& msg : buffer) {
// //     rclcpp::Time msg_time(msg->header.stamp);
// //     double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //     if (time_diff < min_time_diff) {
// //       min_time_diff = time_diff;
// //       closest_msg = msg;
// //     }
// //   }
// //   return closest_msg;
// // }

// // nav_msgs::msg::Odometry::SharedPtr findClosestOdometry(
// //     const std::deque<nav_msgs::msg::Odometry::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //   nav_msgs::msg::Odometry::SharedPtr closest_msg = nullptr;
// //   double min_time_diff = std::numeric_limits<double>::max();

// //   rclcpp::Time target_time_rclcpp(target_time);

// //   for (const auto& msg : buffer) {
// //     rclcpp::Time msg_time(msg->header.stamp);
// //     double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //     if (time_diff < min_time_diff) {
// //       min_time_diff = time_diff;
// //       closest_msg = msg;
// //     }
// //   }
// //   return closest_msg;
// // }


// //   geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr findClosestPoseSimple(
// //     const std::deque<geometry_msgs::msg::PoseStamped::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //     geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr closest_msg = nullptr;
// //     double min_time_diff = std::numeric_limits<double>::max();

// //     rclcpp::Time target_time_rclcpp(target_time);

// //     for (const auto& msg : buffer) {
// //       rclcpp::Time msg_time(msg->header.stamp);
// //       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //       if (time_diff < min_time_diff) {
// //         min_time_diff = time_diff;
// //         closest_msg = msg;
// //       }
// //     }
// //     return closest_msg;
// //   }

// //   geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr findClosestPose(
// //     const std::deque<geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //     geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr closest_msg = nullptr;
// //     double min_time_diff = std::numeric_limits<double>::max();

// //     rclcpp::Time target_time_rclcpp(target_time);

// //     for (const auto& msg : buffer) {
// //       rclcpp::Time msg_time(msg->header.stamp);
// //       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //       if (time_diff < min_time_diff) {
// //         min_time_diff = time_diff;
// //         closest_msg = msg;
// //       }
// //     }
// //     return closest_msg;
// //   }

// //   geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr findClosestTwist(
// //     const std::deque<geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //     geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr closest_msg = nullptr;
// //     double min_time_diff = std::numeric_limits<double>::max();

// //     rclcpp::Time target_time_rclcpp(target_time);

// //     for (const auto& msg : buffer) {
// //       rclcpp::Time msg_time(msg->header.stamp);
// //       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //       if (time_diff < min_time_diff) {
// //         min_time_diff = time_diff;
// //         closest_msg = msg;
// //       }
// //     }
// //     return closest_msg;
// //   }

// //   nav_msgs::msg::Odometry::SharedPtr findClosestOdometry(
// //     const std::deque<nav_msgs::msg::Odometry::SharedPtr>& buffer,
// //     const builtin_interfaces::msg::Time& target_time) {
// //     nav_msgs::msg::Odometry::SharedPtr closest_msg = nullptr;
// //     double min_time_diff = std::numeric_limits<double>::max();

// //     rclcpp::Time target_time_rclcpp(target_time);

// //     for (const auto& msg : buffer) {
// //       rclcpp::Time msg_time(msg->header.stamp);
// //       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
// //       if (time_diff < min_time_diff) {
// //         min_time_diff = time_diff;
// //         closest_msg = msg;
// //       }
// //     }
// //     return closest_msg;
// //   }








//     geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr findClosestPoseSimple(
//     const std::deque<geometry_msgs::msg::PoseStamped::SharedPtr>& buffer,
//     const builtin_interfaces::msg::Time& target_time) {
//     geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr closest_msg = nullptr;
//     double min_time_diff = std::numeric_limits<double>::max();

//     rclcpp::Time target_time_rclcpp(target_time);

//     for (const auto& msg : buffer) {
//       rclcpp::Time msg_time(msg->header.stamp);
//       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
//       if (time_diff < min_time_diff) {
//         min_time_diff = time_diff;
//         closest_msg = msg;
//       }
//     }
//     return closest_msg;
//   }

//   geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr findClosestPose(
//     const std::deque<geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr>& buffer,
//     const builtin_interfaces::msg::Time& target_time) {
//     geometry_msgs::msg::PoseWithCovarianceStamped::SharedPtr closest_msg = nullptr;
//     double min_time_diff = std::numeric_limits<double>::max();

//     rclcpp::Time target_time_rclcpp(target_time);

//     for (const auto& msg : buffer) {
//       rclcpp::Time msg_time(msg->header.stamp);
//       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
//       if (time_diff < min_time_diff) {
//         min_time_diff = time_diff;
//         closest_msg = msg;
//       }
//     }
//     return closest_msg;
//   }

//   geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr findClosestTwist(
//     const std::deque<geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr>& buffer,
//     const builtin_interfaces::msg::Time& target_time) {
//     geometry_msgs::msg::TwistWithCovarianceStamped::SharedPtr closest_msg = nullptr;
//     double min_time_diff = std::numeric_limits<double>::max();

//     rclcpp::Time target_time_rclcpp(target_time);

//     for (const auto& msg : buffer) {
//       rclcpp::Time msg_time(msg->header.stamp);
//       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
//       if (time_diff < min_time_diff) {
//         min_time_diff = time_diff;
//         closest_msg = msg;
//       }
//     }
//     return closest_msg;
//   }

//   nav_msgs::msg::Odometry::SharedPtr findClosestOdometry(
//     const std::deque<nav_msgs::msg::Odometry::SharedPtr>& buffer,
//     const builtin_interfaces::msg::Time& target_time) {
//     nav_msgs::msg::Odometry::SharedPtr closest_msg = nullptr;
//     double min_time_diff = std::numeric_limits<double>::max();

//     rclcpp::Time target_time_rclcpp(target_time);

//     for (const auto& msg : buffer) {
//       rclcpp::Time msg_time(msg->header.stamp);
//       double time_diff = std::abs((msg_time - target_time_rclcpp).seconds());
//       if (time_diff < min_time_diff) {
//         min_time_diff = time_diff;
//         closest_msg = msg;
//       }
//     }
//     return closest_msg;
//   }
//   // ROS Subscribers
//   rclcpp::Subscription<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr sub_pose_lidar_;
//   rclcpp::Subscription<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr sub_pose_gnss_;
//   rclcpp::Subscription<geometry_msgs::msg::TwistWithCovarianceStamped>::SharedPtr sub_twist_lidar_;
//   rclcpp::Subscription<geometry_msgs::msg::TwistWithCovarianceStamped>::SharedPtr sub_twist_gnss_;

//   rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr sub_kinematic_state_lidar_;
//   rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr sub_kinematic_state_gnss_;
//   rclcpp::Subscription<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr sub_biased_pose_lidar_;
//   rclcpp::Subscription<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr sub_biased_pose_gnss_;
//   rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr sub_pose_lidar_simple_;
//   rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr sub_pose_gnss_simple_;

//   // ROS Publishers
//   rclcpp::Publisher<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr pub_pose_;
//   rclcpp::Publisher<geometry_msgs::msg::TwistWithCovarianceStamped>::SharedPtr pub_twist_;
//   rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr pub_kinematic_state_;
//   rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr pub_fused_kinematic_state_;
//   rclcpp::Publisher<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr pub_fused_biased_pose_;
//   rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pub_fused_pose_;

//   std::shared_ptr<tf2_ros::TransformBroadcaster> tf_br_;

//   // Existing fusion variables
//   geometry_msgs::msg::PoseWithCovarianceStamped fused_pose_;
// };

// int main(int argc, char **argv) {
//   rclcpp::init(argc, argv);
//   auto node = std::make_shared<PoseTwistFusionNode>();
//   rclcpp::spin(node);
//   rclcpp::shutdown();
//   return 0;
// }
